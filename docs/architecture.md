# OctoUI Architecture

## Overview

OctoUI is a GPU-native UI rendering engine. It uses OctoFlow's GPU VM to render UI frames via compute shader dispatch chains. All rendering code is written in `.flow` files — zero compiler changes.

## Core Concepts

### GPU VM Dispatch Chain Rendering

Traditional UI toolkits render widgets one at a time with CPU draw calls. OctoUI stages all rendering work as GPU compute dispatches, then executes everything in a single GPU submission:

```
vm_dispatch("ui_clear.spv", ...)     ← clear framebuffer
vm_dispatch("ui_rect.spv", ...)      ← widget 1 background
vm_dispatch("ui_rect.spv", ...)      ← widget 2 background
vm_dispatch("ui_text.spv", ...)      ← glyph 'H'
vm_dispatch("ui_text.spv", ...)      ← glyph 'E'
...
vm_build(vm)                          ← compile to 1 VkCommandBuffer
vm_execute(prog)                      ← 1 vkQueueSubmit
```

### VM Memory Layout

The GPU VM has 5 SSBOs (Shader Storage Buffer Objects):

| Binding | SSBO | OctoUI Usage |
|---------|------|-------------|
| 0 | Registers | Reserved (future GPU layout scratch) |
| 1 | Metrics | Frame time, widget count, dirty count |
| 2 | Globals | **Framebuffer**: R[0..W*H], G[W*H..2*W*H], B[2*W*H..3*W*H] |
| 3 | Control | Reserved (regulator/indirect dispatch) |
| 4 | Heap | Font atlas (384 floats), theme colors |

The framebuffer stores separate R, G, B channels as float arrays. This maps directly to `window_draw(r, g, b)` with zero format conversion.

### Widget Tree (Columnar Storage)

Widgets are stored in parallel arrays (columnar layout), matching OctoFlow's array propagation semantics:

```
_ui_types[]    — widget type constant
_ui_x[]        — absolute x position
_ui_y[]        — absolute y position
_ui_w[]        — width
_ui_h[]        — height
_ui_parent[]   — parent widget ID (-1 for root)
_ui_visible[]  — visibility flag
_ui_state[]    — interaction state (0=normal, 1=hover, 2=pressed)
_ui_colors_r[] — per-widget color R
_ui_colors_g[] — per-widget color G
_ui_colors_b[] — per-widget color B
_ui_texts[]    — text content
```

Widget IDs are array indices. No heap allocation, no GC.

### Layout Engine

Phase 1 uses CPU layout (tree constraint propagation is inherently sequential, and <20 widgets has negligible CPU cost):

- **Pass 1 (bottom-up)**: Compute container sizes from children
- **Pass 2 (top-down)**: Assign absolute positions

Supports COLUMN (vertical stack) and ROW (horizontal stack) containers with spacing and padding.

### Dirty System

Frame-level dirty flag prevents unnecessary re-renders:

- State changes → `ui_mark_dirty()`
- Input events → `ui_mark_dirty()` (on hover/press change)
- Frame loop checks `ui_is_dirty()` before rendering
- After render + present → `ui_clear_dirty()`

## GPU Kernels

Three SPIR-V compute kernels handle all rendering:

### ui_clear.spv
- Push constants: R, G, B, total_pixels
- Fills entire framebuffer with a solid color
- Dispatch: ceil(total_pixels / 256) workgroups

### ui_rect.spv
- Push constants: x0, y0, w, h, R, G, B, screen_w, total_pixels
- Draws a filled rectangle at absolute coordinates
- Each thread maps to one pixel within the rect
- Dispatch: ceil(w * h / 256) workgroups

### ui_text.spv
- Push constants: glyph_idx, dest_x, dest_y, scale, R, G, B, screen_w, total_pixels
- Renders one glyph from the bitmap font (4x6 base, scaled)
- Reads font patterns from Heap (binding 4)
- Bit testing via integer division (no bitwise AND needed)
- Dispatch: ceil(24 * scale^2 / 256) workgroups

All kernels are generated by `.flow` emitter scripts using the IR builder API (`ir.flow`).

## Frame Lifecycle

```
1. ui_process_input(mx, my, mdown)  — hit test, update hover/press
2. Check button clicks                — update reactive state
3. if ui_is_dirty():
     ui_pipeline_render()             — stage + execute dispatch chain
     ui_pipeline_present()            — window_draw(R, G, B)
     ui_clear_dirty()
4. sleep(16ms)                        — ~60fps target
```

## Reactive State

Simple value-binding system:

```
let counter = ui_state(0.0)           — create state slot
ui_bind_text(display_widget, counter) — bind widget text to state
ui_state_set(counter, 5.0)            — updates text + marks dirty
```

## File Structure

```
octoui/
  kernels/           SPIR-V emitters (.flow) + compiled kernels (.spv)
  engine/
    tree.flow        Widget tree (parallel arrays)
    layout.flow      CPU layout engine
    pipeline.flow    GPU render pipeline (dispatch chains)
    dirty.flow       Frame-level dirty tracking
    font.flow        Bitmap font data (4x6, ASCII 32-95)
  widgets/
    core/box.flow    Colored rectangle
    core/text.flow   Text label
    input/button.flow  Clickable button
    layout/row.flow    Horizontal container
    layout/column.flow Vertical container
  themes/
    dark.flow        Dark color theme
  state/
    reactive.flow    Reactive state management
  platform/
    desktop/
      window_win32.flow  Win32 window management
      input.flow         Mouse input processing
  examples/
    hello.flow       Hello World
    counter.flow     Interactive counter (Phase 1 acceptance test)
  tests/
    test_tree.flow      Widget tree tests
    test_kernels.flow   GPU kernel tests
    test_pipeline.flow  Pipeline integration test
```
