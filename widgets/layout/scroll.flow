// widgets/layout/scroll.flow â€” Scroll Container Widget
//
// A vertically-scrolling container that clips children to a fixed viewport.
// Children are laid out as a column with configurable spacing.
// Keyboard scrolling: Up/Down arrows, Page Up/Down when focused.
//
// Usage:
//   let panel = ui_scroll(parent, 300.0, 200.0, 8.0)
//   // Add children to panel...
//   let _b1 = ui_box(panel, 280.0, 60.0, UI_COLOR_SURFACE)
//   let _b2 = ui_box(panel, 280.0, 60.0, UI_COLOR_PRIMARY)
//
//   // After layout, update scroll positions:
//   let _su = ui_scroll_update_all()
//
//   // Scroll control:
//   let _s = ui_scroll_by(panel, 20.0)   // scroll down 20px
//   let _s = ui_scroll_to(panel, 0.0)    // scroll to top

use "../../engine/tree"
use "../../engine/dirty"
use "../../themes/dark"

// Widget type constant
let UI_SCROLL = 14.0

// Scrollbar dimensions
let UI_SCROLL_BAR_W = 8.0
let UI_SCROLL_MIN_THUMB = 16.0
let UI_SCROLL_STEP = 20.0

// Scroll state (indexed by scroll registry index)
let mut _ui_scroll_ids = []        // scroll container widget IDs
let mut _ui_scroll_offset = []     // current scroll offset (pixels)
let mut _ui_scroll_content_h = []  // total content height
let mut _ui_scroll_spacing = []    // spacing between children
let mut _ui_scroll_bar = []        // scrollbar track widget ID
let mut _ui_scroll_thumb = []      // scrollbar thumb widget ID

// Create a scroll container
// parent: parent widget ID (-1.0 for root)
// w: viewport width
// h: viewport height
// spacing: vertical spacing between children
// Returns: container widget ID (use as parent for children)
fn ui_scroll(parent, w, h, spacing)
  // Create the scroll container
  let container = ui_tree_add(UI_SCROLL, parent, w, h, " ")
  let _sc = ui_tree_set_color_themed(container, UI_COLOR_SURFACE)

  // Scrollbar track (right edge, thin box)
  let bar = ui_tree_add(UI_BOX, container, UI_SCROLL_BAR_W, h, " ")
  let _bc = ui_tree_set_color_themed(bar, UI_COLOR_BORDER)

  // Scrollbar thumb (draggable indicator)
  let thumb = ui_tree_add(UI_BOX, container, UI_SCROLL_BAR_W, UI_SCROLL_MIN_THUMB, " ")
  let _tc = ui_tree_set_color_themed(thumb, UI_COLOR_TEXT_DIM)

  // Register
  push(_ui_scroll_ids, container)
  push(_ui_scroll_offset, 0.0)
  push(_ui_scroll_content_h, 0.0)
  push(_ui_scroll_spacing, spacing)
  push(_ui_scroll_bar, bar)
  push(_ui_scroll_thumb, thumb)

  return container
end

// Scroll by delta pixels (positive = down, negative = up)
fn ui_scroll_by(container, delta)
  let n = len(_ui_scroll_ids)
  let mut si = 0.0
  while si < n
    if _ui_scroll_ids[si] == container
      let cur = _ui_scroll_offset[si]
      let _s = ui_scroll_set_offset(si, cur + delta)
      return 0.0
    end
    si = si + 1.0
  end
  return 0.0
end

// Scroll to absolute offset
fn ui_scroll_to(container, offset)
  let n = len(_ui_scroll_ids)
  let mut si = 0.0
  while si < n
    if _ui_scroll_ids[si] == container
      let _s = ui_scroll_set_offset(si, offset)
      return 0.0
    end
    si = si + 1.0
  end
  return 0.0
end

// Internal: set offset with clamping
fn ui_scroll_set_offset(scroll_idx, offset)
  let container = _ui_scroll_ids[scroll_idx]
  let content_h = _ui_scroll_content_h[scroll_idx]
  let viewport_h = _ui_h[container]

  let max_scroll = content_h - viewport_h
  let mut clamped = offset
  if clamped < 0.0
    clamped = 0.0
  end
  if max_scroll > 0.0
    if clamped > max_scroll
      clamped = max_scroll
    end
  else
    clamped = 0.0
  end

  _ui_scroll_offset[scroll_idx] = clamped
  let _d = ui_mark_dirty()
  return 0.0
end

// Update all scroll containers after layout
// Computes content height, positions children, updates scrollbar
fn ui_scroll_update_all()
  let n = len(_ui_scroll_ids)
  let mut si = 0.0
  while si < n
    let container = _ui_scroll_ids[si]
    let cx = _ui_x[container]
    let cy = _ui_y[container]
    let cw = _ui_w[container]
    let ch = _ui_h[container]
    let spacing = _ui_scroll_spacing[si]
    let offset = _ui_scroll_offset[si]
    let bar_id = _ui_scroll_bar[si]
    let thumb_id = _ui_scroll_thumb[si]

    // Phase 1: Position children as a column with scroll offset
    let widget_count = ui_tree_count()
    let mut content_h = 0.0
    let mut child_count = 0.0
    let mut cur_y = cy - offset

    let mut wi = 0.0
    while wi < widget_count
      if _ui_parent[wi] == container
        // Skip scrollbar widgets (they are children but not content)
        let mut is_scrollbar = 0.0
        if wi == bar_id
          is_scrollbar = 1.0
        end
        if wi == thumb_id
          is_scrollbar = 1.0
        end
        if is_scrollbar == 0.0
          // Position child
          _ui_x[wi] = cx
          _ui_y[wi] = cur_y

          // Visibility: hide if fully outside viewport
          let child_bottom = cur_y + _ui_h[wi]
          let view_top = cy
          let view_bottom = cy + ch

          let mut vis = 1.0
          if child_bottom <= view_top
            vis = 0.0
          end
          if cur_y >= view_bottom
            vis = 0.0
          end
          _ui_visible[wi] = vis

          // Accumulate content height
          content_h = content_h + _ui_h[wi]
          child_count = child_count + 1.0

          cur_y = cur_y + _ui_h[wi] + spacing
        end
      end
      wi = wi + 1.0
    end

    // Add spacing to content height
    if child_count > 1.0
      content_h = content_h + spacing * (child_count - 1.0)
    end
    _ui_scroll_content_h[si] = content_h

    // Phase 2: Position and size scrollbar
    let bar_x = cx + cw - UI_SCROLL_BAR_W
    _ui_x[bar_id] = bar_x
    _ui_y[bar_id] = cy
    _ui_h[bar_id] = ch

    if content_h > ch
      // Content overflows: show scrollbar
      _ui_visible[bar_id] = 1.0
      _ui_visible[thumb_id] = 1.0

      let ratio = ch / content_h
      let mut thumb_h = floor(ch * ratio)
      if thumb_h < UI_SCROLL_MIN_THUMB
        thumb_h = UI_SCROLL_MIN_THUMB
      end

      let max_scroll = content_h - ch
      let mut scroll_ratio = 0.0
      if max_scroll > 0.0
        scroll_ratio = offset / max_scroll
      end
      let thumb_range = ch - thumb_h
      let thumb_y = cy + floor(scroll_ratio * thumb_range)

      _ui_x[thumb_id] = bar_x
      _ui_y[thumb_id] = thumb_y
      _ui_w[thumb_id] = UI_SCROLL_BAR_W
      _ui_h[thumb_id] = thumb_h
    else
      // Content fits: hide scrollbar
      _ui_visible[bar_id] = 0.0
      _ui_visible[thumb_id] = 0.0
    end

    si = si + 1.0
  end
  return 0.0
end

// Process keyboard scrolling for focused scroll container
// key: the key string from ui_key_down()
fn ui_scroll_process(key)
  if _ui_focus_id < 0.0
    return 0.0
  end

  // Check if focused widget is inside a scroll container
  let n = len(_ui_scroll_ids)
  let mut si = 0.0
  while si < n
    let container = _ui_scroll_ids[si]
    // Check if focus is the scroll container itself or a descendant
    if _ui_focus_id == container
      let _k = ui_scroll_handle_key(si, key)
      return 0.0
    end
    if ui_tree_is_descendant(_ui_focus_id, container) == 1.0
      let _k = ui_scroll_handle_key(si, key)
      return 0.0
    end
    si = si + 1.0
  end
  return 0.0
end

// Internal: handle key for a specific scroll container
fn ui_scroll_handle_key(scroll_idx, key)
  let container = _ui_scroll_ids[scroll_idx]
  let viewport_h = _ui_h[container]

  if key == "up"
    let _s = ui_scroll_by(container, 0.0 - UI_SCROLL_STEP)
    let _u = ui_scroll_update_all()
  end
  if key == "down"
    let _s = ui_scroll_by(container, UI_SCROLL_STEP)
    let _u = ui_scroll_update_all()
  end
  if key == "pageup"
    let _s = ui_scroll_by(container, 0.0 - viewport_h)
    let _u = ui_scroll_update_all()
  end
  if key == "pagedown"
    let _s = ui_scroll_by(container, viewport_h)
    let _u = ui_scroll_update_all()
  end
  if key == "home"
    let _s = ui_scroll_to(container, 0.0)
    let _u = ui_scroll_update_all()
  end
  if key == "end"
    let content = _ui_scroll_content_h[scroll_idx]
    let _s = ui_scroll_to(container, content)
    let _u = ui_scroll_update_all()
  end
  return 0.0
end

// Get current scroll offset for a container
fn ui_scroll_get_offset(container)
  let n = len(_ui_scroll_ids)
  let mut si = 0.0
  while si < n
    if _ui_scroll_ids[si] == container
      return _ui_scroll_offset[si]
    end
    si = si + 1.0
  end
  return 0.0
end

// Get content height for a container
fn ui_scroll_content_height(container)
  let n = len(_ui_scroll_ids)
  let mut si = 0.0
  while si < n
    if _ui_scroll_ids[si] == container
      return _ui_scroll_content_h[si]
    end
    si = si + 1.0
  end
  return 0.0
end

// Check if content overflows viewport
fn ui_scroll_can_scroll(container)
  let n = len(_ui_scroll_ids)
  let mut si = 0.0
  while si < n
    if _ui_scroll_ids[si] == container
      if _ui_scroll_content_h[si] > _ui_h[container]
        return 1.0
      end
      return 0.0
    end
    si = si + 1.0
  end
  return 0.0
end
