// engine/pipeline.flow — OctoUI GPU Render Pipeline
//
// Core rendering engine. Uses GPU VM dispatch chains to render UI frames:
//   1. Clear framebuffer (ui_clear.spv)
//   2. Draw rectangles per widget (ui_rect.spv)
//   3. Draw text glyphs per character (ui_text.spv)
//   4. Build single VkCommandBuffer (vm_build)
//   5. Submit once (vm_execute)
//   6. Download R/G/B channels (vm_read_globals)
//   7. Present via window_draw
//
// All rendering happens on the GPU. CPU only stages dispatch parameters.

use "tree"
use "dirty"
use "font"
use "../themes/dark"
use "../widgets/core/tooltip"
use "../widgets/core/notification"
use "../widgets/core/modal"
use "../widgets/layout/scroll"
use "../widgets/data/table"
use "../widgets/data/treeview"

// VM state: [0]=vm_id [1]=screen_w [2]=screen_h [3]=initialized [4]=total_pixels
let mut _ui_vm = [0.0, 0.0, 0.0, 0.0, 0.0]

// Framebuffer download arrays
let mut _ui_fb_r = []
let mut _ui_fb_g = []
let mut _ui_fb_b = []

// Push constant arrays (reused per dispatch to avoid allocation)
let mut _ui_pc_clear = [0.0, 0.0, 0.0, 0.0]
let mut _ui_pc_rect = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
let mut _ui_pc_text = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]

// Kernel paths (relative to octoflow working directory)
let _ui_spv_clear = "octoui/kernels/ui_clear.spv"
let _ui_spv_rect = "octoui/kernels/ui_rect.spv"
let _ui_spv_text = "octoui/kernels/ui_text.spv"

// Initialize the render pipeline
// w, h: framebuffer dimensions in pixels
fn ui_pipeline_init(w, h)
  // Initialize font data
  let _fi = ui_font_init()

  let total = w * h

  // Boot GPU VM: 1 instance, 1 register (unused), globals = 3 channels
  let vm = vm_boot(1.0, 1.0, total * 3.0)

  _ui_vm[0] = vm
  _ui_vm[1] = w
  _ui_vm[2] = h
  _ui_vm[3] = 1.0
  _ui_vm[4] = total

  // Upload font data to Heap (binding 4)
  let _sh = vm_set_heap(vm, _ui_font)

  // Pre-allocate framebuffer download arrays
  let mut pi = 0.0
  while pi < total
    push(_ui_fb_r, 0.0)
    push(_ui_fb_g, 0.0)
    push(_ui_fb_b, 0.0)
    pi = pi + 1.0
  end

  // Set screen dimensions for notification and modal positioning
  let _nsw = ui_notify_set_screen_w(w)
  let _mss = ui_modal_set_screen(w, h)

  print("OctoUI pipeline initialized: {w}x{h}")
  return 0.0
end

// Render a complete frame
// Stages all dispatches, builds command buffer, executes on GPU
fn ui_pipeline_render()
  let vm = _ui_vm[0]
  let w = _ui_vm[1]
  let h = _ui_vm[2]
  let total = _ui_vm[4]

  // ── 1. Clear framebuffer ──
  let bg_r = ui_theme_r(UI_COLOR_BG)
  let bg_g = ui_theme_g(UI_COLOR_BG)
  let bg_b = ui_theme_b(UI_COLOR_BG)

  // Colors in 0-255 range, matching window_draw expectation
  _ui_pc_clear[0] = bg_r
  _ui_pc_clear[1] = bg_g
  _ui_pc_clear[2] = bg_b
  _ui_pc_clear[3] = total

  let wg_clear = floor((total + 255.0) / 256.0)
  let _dc = vm_dispatch(vm, _ui_spv_clear, _ui_pc_clear, wg_clear)

  // ── 1b. Draw focus border (before widget rects so it appears behind) ──
  if _ui_focus_id >= 0.0
    let fi = _ui_focus_id
    if fi < len(_ui_types)
      if _ui_visible[fi] == 1.0
        let ftype = _ui_types[fi]
        // Draw focus border for focusable widgets (skip disabled)
        let mut draw_border = 0.0
        if ftype == UI_TEXTINPUT
          draw_border = 1.0
        end
        if ftype == UI_SLIDER
          draw_border = 1.0
        end
        if ftype == UI_BUTTON
          draw_border = 1.0
        end
        if ftype == UI_CHECKBOX
          draw_border = 1.0
        end
        if ftype == UI_RADIO
          draw_border = 1.0
        end
        if ftype == UI_TOGGLE
          draw_border = 1.0
        end
        if ftype == UI_LISTBOX
          draw_border = 1.0
        end
        if ftype == UI_SPINBOX
          draw_border = 1.0
        end
        if ftype == UI_SCROLL
          draw_border = 1.0
        end
        if ftype == UI_TABLE
          draw_border = 1.0
        end
        if ftype == UI_TREEVIEW
          draw_border = 1.0
        end
        if draw_border == 1.0
          if _ui_enabled[fi] == 0.0
            draw_border = 0.0
          end
        end
        if draw_border == 1.0
          let bpad = 2.0
          _ui_pc_rect[0] = _ui_x[fi] - bpad
          _ui_pc_rect[1] = _ui_y[fi] - bpad
          _ui_pc_rect[2] = _ui_w[fi] + bpad * 2.0
          _ui_pc_rect[3] = _ui_h[fi] + bpad * 2.0
          _ui_pc_rect[4] = ui_theme_r(UI_COLOR_PRIMARY)
          _ui_pc_rect[5] = ui_theme_g(UI_COLOR_PRIMARY)
          _ui_pc_rect[6] = ui_theme_b(UI_COLOR_PRIMARY)
          _ui_pc_rect[7] = w
          _ui_pc_rect[8] = total
          let bpixels = ((_ui_w[fi] + bpad * 2.0) * (_ui_h[fi] + bpad * 2.0))
          let bwg = floor((bpixels + 255.0) / 256.0)
          let _db = vm_dispatch(vm, _ui_spv_rect, _ui_pc_rect, bwg)
        end
      end
    end
  end

  // ── 2. Draw widget rectangles ──
  let n = ui_tree_count()
  let mut i = 0.0
  while i < n
    if _ui_visible[i] == 1.0
      let wtype = _ui_types[i]
      // Draw background rect for BOX, BUTTON, CHECKBOX, TEXTINPUT, SLIDER
      if wtype == UI_BOX
        let _dr = ui_pipeline_dispatch_rect(vm, i, w, total)
      end
      if wtype == UI_BUTTON
        let _dr = ui_pipeline_dispatch_rect(vm, i, w, total)
      end
      if wtype == UI_CHECKBOX
        let _dr = ui_pipeline_dispatch_rect(vm, i, w, total)
      end
      if wtype == UI_TEXTINPUT
        let _dr = ui_pipeline_dispatch_rect(vm, i, w, total)
      end
      if wtype == UI_SLIDER
        let _dr = ui_pipeline_dispatch_rect(vm, i, w, total)
      end
      if wtype == UI_RADIO
        let _dr = ui_pipeline_dispatch_rect(vm, i, w, total)
      end
      if wtype == UI_TOGGLE
        let _dr = ui_pipeline_dispatch_rect(vm, i, w, total)
      end
      if wtype == UI_LISTBOX
        let _dr = ui_pipeline_dispatch_rect(vm, i, w, total)
      end
      if wtype == UI_SPINBOX
        let _dr = ui_pipeline_dispatch_rect(vm, i, w, total)
      end
      if wtype == UI_SCROLL
        let _dr = ui_pipeline_dispatch_rect(vm, i, w, total)
      end
      if wtype == UI_TABLE
        let _dr = ui_pipeline_dispatch_rect(vm, i, w, total)
      end
      if wtype == UI_TREEVIEW
        let _dr = ui_pipeline_dispatch_rect(vm, i, w, total)
      end
    end
    i = i + 1.0
  end

  // ── 3. Draw text ──
  let mut j = 0.0
  while j < n
    if _ui_visible[j] == 1.0
      let wtype = _ui_types[j]
      // Draw text for TEXT, BUTTON, and TEXTINPUT widgets
      if wtype == UI_TEXT
        let _dt = ui_pipeline_dispatch_text(vm, j, w, total)
      end
      if wtype == UI_BUTTON
        let _dt = ui_pipeline_dispatch_button_text(vm, j, w, total)
      end
      if wtype == UI_TEXTINPUT
        let _dt = ui_pipeline_dispatch_textinput_text(vm, j, w, total)
      end
      if wtype == UI_SPINBOX
        let _dt = ui_pipeline_dispatch_button_text(vm, j, w, total)
      end
    end
    j = j + 1.0
  end

  // ── 3b. Tooltip overlay (renders on top of everything) ──
  if ui_tooltip_visible() == 1.0
    let tt_text = ui_tooltip_text()
    let tt_x = ui_tooltip_x()
    let tt_y = ui_tooltip_y()
    let tt_len = len(tt_text)
    let tt_scale = 2.0
    let tt_char_w = 5.0 * tt_scale
    let tt_text_h = 6.0 * tt_scale
    let tt_pad = 4.0
    let tt_w = tt_len * tt_char_w + tt_pad * 2.0
    let tt_h = tt_text_h + tt_pad * 2.0

    // Background rect (dark surface)
    _ui_pc_rect[0] = tt_x
    _ui_pc_rect[1] = tt_y
    _ui_pc_rect[2] = tt_w
    _ui_pc_rect[3] = tt_h
    _ui_pc_rect[4] = ui_theme_r(UI_COLOR_SURFACE)
    _ui_pc_rect[5] = ui_theme_g(UI_COLOR_SURFACE)
    _ui_pc_rect[6] = ui_theme_b(UI_COLOR_SURFACE)
    _ui_pc_rect[7] = w
    _ui_pc_rect[8] = total
    let tt_pixels = tt_w * tt_h
    let tt_wg = floor((tt_pixels + 255.0) / 256.0)
    let _dtt = vm_dispatch(vm, _ui_spv_rect, _ui_pc_rect, tt_wg)

    // Border rect (primary color, 1px larger on each side)
    _ui_pc_rect[0] = tt_x - 1.0
    _ui_pc_rect[1] = tt_y - 1.0
    _ui_pc_rect[2] = tt_w + 2.0
    _ui_pc_rect[3] = tt_h + 2.0
    _ui_pc_rect[4] = ui_theme_r(UI_COLOR_BORDER)
    _ui_pc_rect[5] = ui_theme_g(UI_COLOR_BORDER)
    _ui_pc_rect[6] = ui_theme_b(UI_COLOR_BORDER)
    let tt_bp = (tt_w + 2.0) * (tt_h + 2.0)
    let tt_bwg = floor((tt_bp + 255.0) / 256.0)
    let _dttb = vm_dispatch(vm, _ui_spv_rect, _ui_pc_rect, tt_bwg)

    // Re-draw background (on top of border)
    _ui_pc_rect[0] = tt_x
    _ui_pc_rect[1] = tt_y
    _ui_pc_rect[2] = tt_w
    _ui_pc_rect[3] = tt_h
    _ui_pc_rect[4] = ui_theme_r(UI_COLOR_SURFACE)
    _ui_pc_rect[5] = ui_theme_g(UI_COLOR_SURFACE)
    _ui_pc_rect[6] = ui_theme_b(UI_COLOR_SURFACE)
    let _dttf = vm_dispatch(vm, _ui_spv_rect, _ui_pc_rect, tt_wg)

    // Tooltip text
    let tt_cr = ui_theme_r(UI_COLOR_TEXT)
    let tt_cg = ui_theme_g(UI_COLOR_TEXT)
    let tt_cb = ui_theme_b(UI_COLOR_TEXT)
    let tt_tx = tt_x + tt_pad
    let tt_ty = tt_y + tt_pad

    let mut tt_ci = 0.0
    while tt_ci < tt_len
      let tt_ch = char_at(tt_text, tt_ci)
      let tt_code = ord(tt_ch)
      if tt_code > 32.0
        let mut tt_glyph = tt_code - 32.0
        if tt_code >= 97.0
          if tt_code <= 122.0
            tt_glyph = tt_code - 97.0 + 33.0
          end
        end
        if tt_glyph >= 0.0
          if tt_glyph < 64.0
            _ui_pc_text[0] = tt_glyph * 6.0
            _ui_pc_text[1] = tt_tx + tt_ci * tt_char_w
            _ui_pc_text[2] = tt_ty
            _ui_pc_text[3] = tt_scale
            _ui_pc_text[4] = tt_cr
            _ui_pc_text[5] = tt_cg
            _ui_pc_text[6] = tt_cb
            _ui_pc_text[7] = w
            _ui_pc_text[8] = total
            let tt_threads = 24.0 * tt_scale * tt_scale
            let tt_twg = floor((tt_threads + 255.0) / 256.0)
            let _dttg = vm_dispatch(vm, _ui_spv_text, _ui_pc_text, tt_twg)
          end
        end
      end
      tt_ci = tt_ci + 1.0
    end
  end

  // ── 3c. Notification overlay ──
  if ui_notify_visible() == 1.0
    let nt_text = ui_notify_text()
    let nt_x = ui_notify_x()
    let nt_y = ui_notify_y()
    let nt_len = len(nt_text)
    let nt_scale = 2.0
    let nt_char_w = 5.0 * nt_scale
    let nt_text_h = 6.0 * nt_scale
    let nt_pad = 8.0
    let nt_w = nt_len * nt_char_w + nt_pad * 2.0
    let nt_h = nt_text_h + nt_pad * 2.0
    let nt_cidx = ui_notify_color()

    // Background rect (notification color)
    _ui_pc_rect[0] = nt_x
    _ui_pc_rect[1] = nt_y
    _ui_pc_rect[2] = nt_w
    _ui_pc_rect[3] = nt_h
    _ui_pc_rect[4] = ui_theme_r(nt_cidx)
    _ui_pc_rect[5] = ui_theme_g(nt_cidx)
    _ui_pc_rect[6] = ui_theme_b(nt_cidx)
    _ui_pc_rect[7] = w
    _ui_pc_rect[8] = total
    let nt_pixels = nt_w * nt_h
    let nt_wg = floor((nt_pixels + 255.0) / 256.0)
    let _dnt = vm_dispatch(vm, _ui_spv_rect, _ui_pc_rect, nt_wg)

    // Text (white for contrast on colored background)
    let nt_tx = nt_x + nt_pad
    let nt_ty = nt_y + nt_pad

    let mut nt_ci = 0.0
    while nt_ci < nt_len
      let nt_ch = char_at(nt_text, nt_ci)
      let nt_code = ord(nt_ch)
      if nt_code > 32.0
        let mut nt_glyph = nt_code - 32.0
        if nt_code >= 97.0
          if nt_code <= 122.0
            nt_glyph = nt_code - 97.0 + 33.0
          end
        end
        if nt_glyph >= 0.0
          if nt_glyph < 64.0
            _ui_pc_text[0] = nt_glyph * 6.0
            _ui_pc_text[1] = nt_tx + nt_ci * nt_char_w
            _ui_pc_text[2] = nt_ty
            _ui_pc_text[3] = nt_scale
            _ui_pc_text[4] = ui_theme_r(UI_COLOR_TEXT)
            _ui_pc_text[5] = ui_theme_g(UI_COLOR_TEXT)
            _ui_pc_text[6] = ui_theme_b(UI_COLOR_TEXT)
            _ui_pc_text[7] = w
            _ui_pc_text[8] = total
            let nt_threads = 24.0 * nt_scale * nt_scale
            let nt_twg = floor((nt_threads + 255.0) / 256.0)
            let _dntg = vm_dispatch(vm, _ui_spv_text, _ui_pc_text, nt_twg)
          end
        end
      end
      nt_ci = nt_ci + 1.0
    end
  end

  // ── 3d. Modal overlay (dim background + re-render modal widgets on top) ──
  let modal_cid = ui_modal_container()
  if modal_cid >= 0.0
    // Dim overlay: dark rect covering entire screen
    _ui_pc_rect[0] = 0.0
    _ui_pc_rect[1] = 0.0
    _ui_pc_rect[2] = w
    _ui_pc_rect[3] = h
    let dim_r = floor(ui_theme_r(UI_COLOR_BG) / 2.0)
    let dim_g = floor(ui_theme_g(UI_COLOR_BG) / 2.0)
    let dim_b = floor(ui_theme_b(UI_COLOR_BG) / 2.0)
    _ui_pc_rect[4] = dim_r
    _ui_pc_rect[5] = dim_g
    _ui_pc_rect[6] = dim_b
    _ui_pc_rect[7] = w
    _ui_pc_rect[8] = total
    let dim_wg = floor((total + 255.0) / 256.0)
    let _ddim = vm_dispatch(vm, _ui_spv_rect, _ui_pc_rect, dim_wg)

    // Re-render modal widget rects
    let mn = ui_tree_count()
    let mut mi = 0.0
    while mi < mn
      if _ui_visible[mi] == 1.0
        if ui_tree_is_descendant(mi, modal_cid) == 1.0
          let mwtype = _ui_types[mi]
          let mut mdraw = 0.0
          if mwtype == UI_BOX
            mdraw = 1.0
          end
          if mwtype == UI_BUTTON
            mdraw = 1.0
          end
          if mwtype == UI_CHECKBOX
            mdraw = 1.0
          end
          if mwtype == UI_TEXTINPUT
            mdraw = 1.0
          end
          if mwtype == UI_SLIDER
            mdraw = 1.0
          end
          if mwtype == UI_RADIO
            mdraw = 1.0
          end
          if mwtype == UI_TOGGLE
            mdraw = 1.0
          end
          if mwtype == UI_COLUMN
            // Draw column if it has a color (like the panel)
            if _ui_color_idx[mi] >= 0.0
              mdraw = 1.0
            end
          end
          if mwtype == UI_ROW
            if _ui_color_idx[mi] >= 0.0
              mdraw = 1.0
            end
          end
          if mwtype == UI_TABLE
            mdraw = 1.0
          end
          if mwtype == UI_TREEVIEW
            mdraw = 1.0
          end
          if mdraw == 1.0
            let _mdr = ui_pipeline_dispatch_rect(vm, mi, w, total)
          end
        end
      end
      mi = mi + 1.0
    end

    // Re-render modal widget text
    let mut mj = 0.0
    while mj < mn
      if _ui_visible[mj] == 1.0
        if ui_tree_is_descendant(mj, modal_cid) == 1.0
          let mwtype2 = _ui_types[mj]
          if mwtype2 == UI_TEXT
            let _mdt = ui_pipeline_dispatch_text(vm, mj, w, total)
          end
          if mwtype2 == UI_BUTTON
            let _mdt2 = ui_pipeline_dispatch_button_text(vm, mj, w, total)
          end
        end
      end
      mj = mj + 1.0
    end
  end

  // ── 4. Build single command buffer ──
  let prog = vm_build(vm)

  // ── 5. Execute on GPU (single vkQueueSubmit) ──
  let _ex = vm_execute(prog)

  // ── 6. Download framebuffer channels ──
  // Must use `let` so eval_array_fn handles vm_read_globals (array-returning).
  // GPU_ARRAYS stores by name; window_draw finds them via gpu_array_get.
  let _ui_fb_r = vm_read_globals(vm, 0.0, total)
  let _ui_fb_g = vm_read_globals(vm, total, total)
  let _ui_fb_b = vm_read_globals(vm, total * 2.0, total)

  return 0.0
end

// Present the rendered frame to the window
fn ui_pipeline_present()
  let _wd = window_draw(_ui_fb_r, _ui_fb_g, _ui_fb_b)
  return 0.0
end

// Shut down the render pipeline
fn ui_pipeline_shutdown()
  let vm = _ui_vm[0]
  let _s = vm_shutdown(vm)
  _ui_vm[3] = 0.0
  return 0.0
end

// ── Internal helpers ──

// Dispatch a rect for widget at index i
fn ui_pipeline_dispatch_rect(vm, idx, screen_w, total)
  let x0 = _ui_x[idx]
  let y0 = _ui_y[idx]
  let rw = _ui_w[idx]
  let rh = _ui_h[idx]
  let mut cr = _ui_colors_r[idx]
  let mut cg = _ui_colors_g[idx]
  let mut cb = _ui_colors_b[idx]

  // Dim disabled widgets (blend 60% toward background)
  if _ui_enabled[idx] == 0.0
    let dbg_r = ui_theme_r(UI_COLOR_BG)
    let dbg_g = ui_theme_g(UI_COLOR_BG)
    let dbg_b = ui_theme_b(UI_COLOR_BG)
    cr = floor(cr * 0.4 + dbg_r * 0.6)
    cg = floor(cg * 0.4 + dbg_g * 0.6)
    cb = floor(cb * 0.4 + dbg_b * 0.6)
  end

  _ui_pc_rect[0] = x0
  _ui_pc_rect[1] = y0
  _ui_pc_rect[2] = rw
  _ui_pc_rect[3] = rh
  _ui_pc_rect[4] = cr
  _ui_pc_rect[5] = cg
  _ui_pc_rect[6] = cb
  _ui_pc_rect[7] = screen_w
  _ui_pc_rect[8] = total

  let pixels = rw * rh
  let wg = floor((pixels + 255.0) / 256.0)
  let _d = vm_dispatch(vm, _ui_spv_rect, _ui_pc_rect, wg)
  return 0.0
end

// Dispatch text glyphs for a TEXT widget
fn ui_pipeline_dispatch_text(vm, idx, screen_w, total)
  let text = _ui_texts[idx]
  let tx = _ui_x[idx]
  let ty = _ui_y[idx]
  let mut cr = _ui_colors_r[idx]
  let mut cg = _ui_colors_g[idx]
  let mut cb = _ui_colors_b[idx]

  // Dim disabled text (use TEXT_DIM color)
  if _ui_enabled[idx] == 0.0
    cr = ui_theme_r(UI_COLOR_TEXT_DIM)
    cg = ui_theme_g(UI_COLOR_TEXT_DIM)
    cb = ui_theme_b(UI_COLOR_TEXT_DIM)
  end

  let scale = 2.0
  let char_w = 5.0 * scale

  let tlen = len(text)
  let mut ci = 0.0
  while ci < tlen
    let ch = char_at(text, ci)
    let ch_code = ord(ch)

    // Map character to glyph index
    let mut glyph_idx = ch_code - 32.0
    // Map lowercase to uppercase
    if ch_code >= 97.0
      if ch_code <= 122.0
        glyph_idx = ch_code - 97.0 + 33.0
      end
    end

    // Skip if out of font range
    if glyph_idx >= 0.0
      if glyph_idx < 64.0
        let dx = tx + ci * char_w
        let dy = ty + 2.0

        // Kernel expects font atlas offset: glyph_num * 6 (6 rows per glyph)
        _ui_pc_text[0] = glyph_idx * 6.0
        _ui_pc_text[1] = dx
        _ui_pc_text[2] = dy
        _ui_pc_text[3] = scale
        _ui_pc_text[4] = cr
        _ui_pc_text[5] = cg
        _ui_pc_text[6] = cb
        _ui_pc_text[7] = screen_w
        _ui_pc_text[8] = total

        // Threads = 4*scale * 6*scale = 24 * scale * scale
        let threads = 24.0 * scale * scale
        let wg = floor((threads + 255.0) / 256.0)
        let _d = vm_dispatch(vm, _ui_spv_text, _ui_pc_text, wg)
      end
    end
    ci = ci + 1.0
  end
  return 0.0
end

// Dispatch text for a BUTTON widget (centered in button rect)
fn ui_pipeline_dispatch_button_text(vm, idx, screen_w, total)
  let text = _ui_texts[idx]
  let bx = _ui_x[idx]
  let by = _ui_y[idx]
  let bw = _ui_w[idx]
  let bh = _ui_h[idx]
  let scale = 2.0
  let char_w = 5.0 * scale
  let text_h = 6.0 * scale

  // Center text in button
  let tlen = len(text)
  let text_w = tlen * char_w
  let tx = bx + floor((bw - text_w) / 2.0)
  let ty = by + floor((bh - text_h) / 2.0)

  // Use dimmed color for disabled buttons, normal text color otherwise
  let mut cr = ui_theme_r(UI_COLOR_TEXT)
  let mut cg = ui_theme_g(UI_COLOR_TEXT)
  let mut cb = ui_theme_b(UI_COLOR_TEXT)
  if _ui_enabled[idx] == 0.0
    cr = ui_theme_r(UI_COLOR_TEXT_DIM)
    cg = ui_theme_g(UI_COLOR_TEXT_DIM)
    cb = ui_theme_b(UI_COLOR_TEXT_DIM)
  end

  let mut ci = 0.0
  while ci < tlen
    let ch = char_at(text, ci)
    let ch_code = ord(ch)

    let mut glyph_idx = ch_code - 32.0
    if ch_code >= 97.0
      if ch_code <= 122.0
        glyph_idx = ch_code - 97.0 + 33.0
      end
    end

    if glyph_idx >= 0.0
      if glyph_idx < 64.0
        let dx = tx + ci * char_w
        let dy = ty

        // Kernel expects font atlas offset: glyph_num * 6 (6 rows per glyph)
        _ui_pc_text[0] = glyph_idx * 6.0
        _ui_pc_text[1] = dx
        _ui_pc_text[2] = dy
        _ui_pc_text[3] = scale
        _ui_pc_text[4] = cr
        _ui_pc_text[5] = cg
        _ui_pc_text[6] = cb
        _ui_pc_text[7] = screen_w
        _ui_pc_text[8] = total

        let threads = 24.0 * scale * scale
        let wg = floor((threads + 255.0) / 256.0)
        let _d = vm_dispatch(vm, _ui_spv_text, _ui_pc_text, wg)
      end
    end
    ci = ci + 1.0
  end
  return 0.0
end

// Dispatch text for a TEXTINPUT widget (left-aligned with padding, cursor when focused)
fn ui_pipeline_dispatch_textinput_text(vm, idx, screen_w, total)
  let text = _ui_texts[idx]
  let bx = _ui_x[idx]
  let by = _ui_y[idx]
  let bh = _ui_h[idx]
  let scale = 2.0
  let char_w = 5.0 * scale
  let text_h = 6.0 * scale
  let text_pad = 6.0

  // Left-aligned, vertically centered
  let tx = bx + text_pad
  let ty = by + floor((bh - text_h) / 2.0)

  // Use dimmed color for disabled text inputs
  let mut cr = ui_theme_r(UI_COLOR_TEXT)
  let mut cg = ui_theme_g(UI_COLOR_TEXT)
  let mut cb = ui_theme_b(UI_COLOR_TEXT)
  if _ui_enabled[idx] == 0.0
    cr = ui_theme_r(UI_COLOR_TEXT_DIM)
    cg = ui_theme_g(UI_COLOR_TEXT_DIM)
    cb = ui_theme_b(UI_COLOR_TEXT_DIM)
  end

  let tlen = len(text)
  let mut ti = 0.0
  while ti < tlen
    let ch = char_at(text, ti)
    let ch_code = ord(ch)

    // Skip space character (used as "empty")
    if ch_code > 32.0
      let mut glyph_idx = ch_code - 32.0
      if ch_code >= 97.0
        if ch_code <= 122.0
          glyph_idx = ch_code - 97.0 + 33.0
        end
      end

      if glyph_idx >= 0.0
        if glyph_idx < 64.0
          let dx = tx + ti * char_w

          _ui_pc_text[0] = glyph_idx * 6.0
          _ui_pc_text[1] = dx
          _ui_pc_text[2] = ty
          _ui_pc_text[3] = scale
          _ui_pc_text[4] = cr
          _ui_pc_text[5] = cg
          _ui_pc_text[6] = cb
          _ui_pc_text[7] = screen_w
          _ui_pc_text[8] = total

          let threads = 24.0 * scale * scale
          let wg = floor((threads + 255.0) / 256.0)
          let _dt = vm_dispatch(vm, _ui_spv_text, _ui_pc_text, wg)
        end
      end
    end
    ti = ti + 1.0
  end

  // Draw cursor if this widget has focus and is enabled
  if idx == _ui_focus_id
    if _ui_enabled[idx] == 0.0
      return 0.0
    end
    // Use cursor position from textinput module (if available)
    let mut cpos = tlen
    if idx < len(_ui_ti_cursor)
      cpos = _ui_ti_cursor[idx]
    end
    let cursor_x = tx + cpos * char_w
    let cursor_y = by + 3.0
    let cursor_h = bh - 6.0
    // Cursor: 2px wide rect in text color
    _ui_pc_rect[0] = cursor_x
    _ui_pc_rect[1] = cursor_y
    _ui_pc_rect[2] = 2.0
    _ui_pc_rect[3] = cursor_h
    _ui_pc_rect[4] = cr
    _ui_pc_rect[5] = cg
    _ui_pc_rect[6] = cb
    _ui_pc_rect[7] = screen_w
    _ui_pc_rect[8] = total
    let pixels = 2.0 * cursor_h
    let wg2 = floor((pixels + 255.0) / 256.0)
    let _dc = vm_dispatch(vm, _ui_spv_rect, _ui_pc_rect, wg2)
  end

  return 0.0
end
