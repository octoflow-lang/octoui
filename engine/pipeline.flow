// engine/pipeline.flow — OctoUI GPU Render Pipeline
//
// Core rendering engine. Uses GPU VM dispatch chains to render UI frames:
//   1. Present previous frame (vm_wait — usually instant, GPU worked during idle)
//   2. Collect all text for frame (gdi_text_begin/add/atlas)
//   3. Upload text atlas to GPU heap
//   4. Clear framebuffer (ui_clear.spv)
//   5. Draw rectangles per widget (ui_rect.spv)
//   6. Draw text blits per widget (ui_text_blit.spv)
//   7. Build single VkCommandBuffer (vm_build)
//   8. Async submit (vm_execute_async — returns instantly)
//
// Two-phase rendering: Phase A collects all text via GDI rasterizer (cached),
// packs into atlas, uploads to GPU heap. Phase B dispatches GPU work.

use "tree"
use "dirty"
use "sdf_font"
use "../themes/dark"
use "../widgets/core/tooltip"
use "../widgets/core/notification"
use "../widgets/core/modal"
use "../widgets/layout/scroll"
use "../widgets/data/table"
use "../widgets/data/treeview"
use "../widgets/input/textarea"

// VM state: [0]=vm_id [1]=screen_w [2]=screen_h [3]=initialized [4]=total_pixels [5]=prev_prog_id
let mut _ui_vm = [0.0, 0.0, 0.0, 0.0, 0.0, -1.0]

// Push constant arrays (reused per dispatch to avoid allocation)
let mut _ui_pc_clear = [0.0, 0.0, 0.0, 0.0]
let mut _ui_pc_rect = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
let mut _ui_pc_blit = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]

// Text queue: stride 6 [batch_idx, dest_x, dest_y, color_r, color_g, color_b]
let mut _ui_tq = []
// Modal text queue: same format, dispatched on top of dim overlay
let mut _ui_tq_modal = []

// Kernel paths (relative to octoflow working directory)
let _ui_spv_clear = "octoui/kernels/ui_clear.spv"
let _ui_spv_rect = "octoui/kernels/ui_rect.spv"
let _ui_blit_spv = "octoui/kernels/ui_text_blit.spv"

// Initialize the render pipeline
// w, h: framebuffer dimensions in pixels
fn ui_pipeline_init(w, h)
  let total = w * h

  // Boot GPU VM: globals hold framebuffer (total*3 for planar RGB)
  let globals_size = total * 3.0
  let vm = vm_boot(1.0, 1.0, globals_size)

  _ui_vm[0] = vm
  _ui_vm[1] = w
  _ui_vm[2] = h
  _ui_vm[3] = 1.0
  _ui_vm[4] = total

  // Initialize font system (GDI backend — no atlas generation)
  let _fi = ui_sdf_font_init(vm)

  // ── Pipeline warm-up ──
  // Compile SPIR-V kernels NOW so first render frame gets cache hits.
  let _pc4 = [0.0, 0.0, 0.0, 0.0]
  let _pc9 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  let _pc10 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  let _wu1 = vm_dispatch(vm, _ui_spv_clear, _pc4, 1.0)
  let _wu2 = vm_dispatch(vm, _ui_spv_rect, _pc9, 1.0)
  let _wu3 = vm_dispatch(vm, _ui_blit_spv, _pc10, 1.0)
  let prog_wu = vm_build(vm)
  let _ewu = vm_execute(prog_wu)
  let _fwu = vm_free_prog(prog_wu)

  // Set screen dimensions for notification and modal positioning
  let _nsw = ui_notify_set_screen_w(w)
  let _mss = ui_modal_set_screen(w, h)

  print("OctoUI pipeline initialized: {w}x{h}")
  return 0.0
end

// Present the previous frame if one is pending (wait + download + blit)
fn ui_pipeline_present_pending()
  let prev = _ui_vm[5]
  if prev >= 0.0
    let _w = vm_wait(prev)
    let vm = _ui_vm[0]
    let total = _ui_vm[4]
    let _p = vm_present(vm, total)
    let _f = vm_free_prog(prev)
    _ui_vm[5] = -1.0
  end
  return 0.0
end

// Render a complete frame
fn ui_pipeline_render()
  let vm = _ui_vm[0]
  let w = _ui_vm[1]
  let h = _ui_vm[2]
  let total = _ui_vm[4]

  // ── 0. Present previous frame (wait usually instant — GPU worked during idle) ──
  let prev = _ui_vm[5]
  if prev >= 0.0
    let _w = vm_wait(prev)
    let _p = vm_present(vm, total)
    let _f = vm_free_prog(prev)
    _ui_vm[5] = -1.0
  end

  let n = ui_tree_count()
  let modal_cid = ui_modal_container()

  // ═══════════════════════════════════════════════════════════════
  // Phase A: Collect all text for this frame
  // ═══════════════════════════════════════════════════════════════
  let _tb = gdi_text_begin()

  // Clear text queues
  while len(_ui_tq) > 0.0
    let _p = pop(_ui_tq)
  end
  while len(_ui_tq_modal) > 0.0
    let _p = pop(_ui_tq_modal)
  end

  // ── Collect widget text ──
  let mut ci = 0.0
  while ci < n
    if _ui_visible[ci] == 1.0
      let wtype = _ui_types[ci]

      // TEXT widget: left-aligned
      if wtype == UI_TEXT
        let text = _ui_texts[ci]
        let font_size = 16.0
        let bidx = gdi_text_add(text, font_size)
        let tx = _ui_x[ci]
        let ty = _ui_y[ci]
        let mut cr = _ui_colors_r[ci]
        let mut cg = _ui_colors_g[ci]
        let mut cb = _ui_colors_b[ci]
        if _ui_enabled[ci] == 0.0
          cr = ui_theme_r(UI_COLOR_TEXT_DIM)
          cg = ui_theme_g(UI_COLOR_TEXT_DIM)
          cb = ui_theme_b(UI_COLOR_TEXT_DIM)
        end
        push(_ui_tq, bidx)
        push(_ui_tq, tx)
        push(_ui_tq, ty)
        push(_ui_tq, cr)
        push(_ui_tq, cg)
        push(_ui_tq, cb)
        if modal_cid >= 0.0
          if ui_tree_is_descendant(ci, modal_cid) == 1.0
            push(_ui_tq_modal, bidx)
            push(_ui_tq_modal, tx)
            push(_ui_tq_modal, ty)
            push(_ui_tq_modal, cr)
            push(_ui_tq_modal, cg)
            push(_ui_tq_modal, cb)
          end
        end
      end

      // BUTTON / SPINBOX: centered text
      if wtype == UI_BUTTON
        let text = _ui_texts[ci]
        let font_size = 16.0
        let bidx = gdi_text_add(text, font_size)
        let tw = gdi_text_w(bidx)
        let th = gdi_text_h(bidx)
        let tx = _ui_x[ci] + floor((_ui_w[ci] - tw) / 2.0)
        let ty = _ui_y[ci] + floor((_ui_h[ci] - th) / 2.0)
        let mut cr = ui_theme_r(UI_COLOR_TEXT)
        let mut cg = ui_theme_g(UI_COLOR_TEXT)
        let mut cb = ui_theme_b(UI_COLOR_TEXT)
        if _ui_enabled[ci] == 0.0
          cr = ui_theme_r(UI_COLOR_TEXT_DIM)
          cg = ui_theme_g(UI_COLOR_TEXT_DIM)
          cb = ui_theme_b(UI_COLOR_TEXT_DIM)
        end
        push(_ui_tq, bidx)
        push(_ui_tq, tx)
        push(_ui_tq, ty)
        push(_ui_tq, cr)
        push(_ui_tq, cg)
        push(_ui_tq, cb)
        if modal_cid >= 0.0
          if ui_tree_is_descendant(ci, modal_cid) == 1.0
            push(_ui_tq_modal, bidx)
            push(_ui_tq_modal, tx)
            push(_ui_tq_modal, ty)
            push(_ui_tq_modal, cr)
            push(_ui_tq_modal, cg)
            push(_ui_tq_modal, cb)
          end
        end
      end

      if wtype == UI_SPINBOX
        let text = _ui_texts[ci]
        let font_size = 16.0
        let bidx = gdi_text_add(text, font_size)
        let tw = gdi_text_w(bidx)
        let th = gdi_text_h(bidx)
        let tx = _ui_x[ci] + floor((_ui_w[ci] - tw) / 2.0)
        let ty = _ui_y[ci] + floor((_ui_h[ci] - th) / 2.0)
        let mut cr = ui_theme_r(UI_COLOR_TEXT)
        let mut cg = ui_theme_g(UI_COLOR_TEXT)
        let mut cb = ui_theme_b(UI_COLOR_TEXT)
        if _ui_enabled[ci] == 0.0
          cr = ui_theme_r(UI_COLOR_TEXT_DIM)
          cg = ui_theme_g(UI_COLOR_TEXT_DIM)
          cb = ui_theme_b(UI_COLOR_TEXT_DIM)
        end
        push(_ui_tq, bidx)
        push(_ui_tq, tx)
        push(_ui_tq, ty)
        push(_ui_tq, cr)
        push(_ui_tq, cg)
        push(_ui_tq, cb)
        if modal_cid >= 0.0
          if ui_tree_is_descendant(ci, modal_cid) == 1.0
            push(_ui_tq_modal, bidx)
            push(_ui_tq_modal, tx)
            push(_ui_tq_modal, ty)
            push(_ui_tq_modal, cr)
            push(_ui_tq_modal, cg)
            push(_ui_tq_modal, cb)
          end
        end
      end

      // TEXTINPUT: left-padded with placeholder/password handling
      if wtype == UI_TEXTINPUT
        let text = _ui_texts[ci]
        let font_size = 16.0
        let text_pad = 6.0
        let mut display_text = text
        let mut cr = ui_theme_r(UI_COLOR_TEXT)
        let mut cg = ui_theme_g(UI_COLOR_TEXT)
        let mut cb = ui_theme_b(UI_COLOR_TEXT)

        let mut is_empty = 0.0
        if text == " "
          is_empty = 1.0
        end

        // Placeholder
        if is_empty == 1.0
          if ci != _ui_focus_id
            if ci < len(_ui_ti_placeholder)
              let ph = _ui_ti_placeholder[ci]
              if ph != " "
                display_text = ph
                cr = ui_theme_r(UI_COLOR_TEXT_DIM)
                cg = ui_theme_g(UI_COLOR_TEXT_DIM)
                cb = ui_theme_b(UI_COLOR_TEXT_DIM)
              end
            end
          end
        end

        // Password masking
        let mut is_password = 0.0
        if ci < len(_ui_ti_password)
          if _ui_ti_password[ci] == 1.0
            is_password = 1.0
          end
        end
        if is_password == 1.0
          if is_empty == 0.0
            let tlen = len(display_text)
            let mut masked = chr(42.0)
            let mut mi = 1.0
            while mi < tlen
              masked = masked + chr(42.0)
              mi = mi + 1.0
            end
            display_text = masked
          end
        end

        // Disabled / readonly colors
        if _ui_enabled[ci] == 0.0
          cr = ui_theme_r(UI_COLOR_TEXT_DIM)
          cg = ui_theme_g(UI_COLOR_TEXT_DIM)
          cb = ui_theme_b(UI_COLOR_TEXT_DIM)
        end
        if ci < len(_ui_ti_readonly)
          if _ui_ti_readonly[ci] == 1.0
            if _ui_enabled[ci] == 1.0
              cr = ui_theme_r(UI_COLOR_TEXT)
              cg = ui_theme_g(UI_COLOR_TEXT)
              cb = ui_theme_b(UI_COLOR_TEXT)
            end
          end
        end

        let bidx = gdi_text_add(display_text, font_size)
        let tx = _ui_x[ci] + text_pad
        let ty = _ui_y[ci] + floor((_ui_h[ci] - font_size) / 2.0)
        push(_ui_tq, bidx)
        push(_ui_tq, tx)
        push(_ui_tq, ty)
        push(_ui_tq, cr)
        push(_ui_tq, cg)
        push(_ui_tq, cb)
        if modal_cid >= 0.0
          if ui_tree_is_descendant(ci, modal_cid) == 1.0
            push(_ui_tq_modal, bidx)
            push(_ui_tq_modal, tx)
            push(_ui_tq_modal, ty)
            push(_ui_tq_modal, cr)
            push(_ui_tq_modal, cg)
            push(_ui_tq_modal, cb)
          end
        end
      end

      // TEXTAREA: per visible line
      if wtype == UI_TEXTAREA
        let mut ta_idx = -1.0
        let mut fi = 0.0
        while fi < len(_ui_ta_widgets)
          if _ui_ta_widgets[fi] == ci
            ta_idx = fi
          end
          fi = fi + 1.0
        end
        if ta_idx >= 0.0
          let font_size = 16.0
          let line_h = 16.0
          let text_pad = 4.0
          let cr = ui_theme_r(UI_COLOR_TEXT)
          let cg = ui_theme_g(UI_COLOR_TEXT)
          let cb = ui_theme_b(UI_COLOR_TEXT)

          let scroll = _ui_ta_scroll[ta_idx]
          let line_count = _ui_ta_line_count[ta_idx]
          let start = _ui_ta_line_start[ta_idx]
          let bh = _ui_h[ci]
          let vis_lines = floor(bh / line_h)

          let mut li = 0.0
          while li < vis_lines
            let line_idx = scroll + li
            if line_idx < line_count
              let flat_idx = start + line_idx
              let line_text = _ui_ta_lines[flat_idx]
              let bidx = gdi_text_add(line_text, font_size)
              let lx = _ui_x[ci] + text_pad
              let ly = _ui_y[ci] + li * line_h + 2.0
              push(_ui_tq, bidx)
              push(_ui_tq, lx)
              push(_ui_tq, ly)
              push(_ui_tq, cr)
              push(_ui_tq, cg)
              push(_ui_tq, cb)
              if modal_cid >= 0.0
                if ui_tree_is_descendant(ci, modal_cid) == 1.0
                  push(_ui_tq_modal, bidx)
                  push(_ui_tq_modal, lx)
                  push(_ui_tq_modal, ly)
                  push(_ui_tq_modal, cr)
                  push(_ui_tq_modal, cg)
                  push(_ui_tq_modal, cb)
                end
              end
            end
            li = li + 1.0
          end
        end
      end
    end
    ci = ci + 1.0
  end

  // ── Collect overlay text ──
  let mut tt_bidx = -1.0
  let mut tt_bx = 0.0
  let mut tt_by = 0.0
  let mut tt_cr = 0.0
  let mut tt_cg = 0.0
  let mut tt_cb = 0.0
  let mut tt_visible = 0.0
  if ui_tooltip_visible() == 1.0
    tt_visible = 1.0
    let tt_text = ui_tooltip_text()
    tt_bidx = gdi_text_add(tt_text, 14.0)
    tt_bx = ui_tooltip_x() + 4.0
    tt_by = ui_tooltip_y() + 4.0
    tt_cr = ui_theme_r(UI_COLOR_TEXT)
    tt_cg = ui_theme_g(UI_COLOR_TEXT)
    tt_cb = ui_theme_b(UI_COLOR_TEXT)
  end

  let mut nt_bidx = -1.0
  let mut nt_bx = 0.0
  let mut nt_by = 0.0
  let mut nt_cr = 0.0
  let mut nt_cg = 0.0
  let mut nt_cb = 0.0
  let mut nt_visible = 0.0
  if ui_notify_visible() == 1.0
    nt_visible = 1.0
    let nt_text = ui_notify_text()
    nt_bidx = gdi_text_add(nt_text, 16.0)
    nt_bx = ui_notify_x() + 8.0
    nt_by = ui_notify_y() + 8.0
    nt_cr = ui_theme_r(UI_COLOR_TEXT)
    nt_cg = ui_theme_g(UI_COLOR_TEXT)
    nt_cb = ui_theme_b(UI_COLOR_TEXT)
  end

  // ── Atlas upload ──
  let atlas = gdi_text_atlas()
  let _sh = vm_set_heap(vm, atlas)

  // ═══════════════════════════════════════════════════════════════
  // Phase B: GPU dispatches
  // ═══════════════════════════════════════════════════════════════

  // ── 1. Clear framebuffer ──
  let bg_r = ui_theme_r(UI_COLOR_BG)
  let bg_g = ui_theme_g(UI_COLOR_BG)
  let bg_b = ui_theme_b(UI_COLOR_BG)
  _ui_pc_clear[0] = bg_r
  _ui_pc_clear[1] = bg_g
  _ui_pc_clear[2] = bg_b
  _ui_pc_clear[3] = total
  let wg_clear = floor((total + 255.0) / 256.0)
  let _dc = vm_dispatch(vm, _ui_spv_clear, _ui_pc_clear, wg_clear)

  // ── 1b. Draw focus border ──
  if _ui_focus_id >= 0.0
    let fi = _ui_focus_id
    if fi < len(_ui_types)
      if _ui_visible[fi] == 1.0
        let ftype = _ui_types[fi]
        let mut draw_border = 0.0
        if ftype == UI_TEXTINPUT
          draw_border = 1.0
        end
        if ftype == UI_SLIDER
          draw_border = 1.0
        end
        if ftype == UI_BUTTON
          draw_border = 1.0
        end
        if ftype == UI_CHECKBOX
          draw_border = 1.0
        end
        if ftype == UI_RADIO
          draw_border = 1.0
        end
        if ftype == UI_TOGGLE
          draw_border = 1.0
        end
        if ftype == UI_LISTBOX
          draw_border = 1.0
        end
        if ftype == UI_SPINBOX
          draw_border = 1.0
        end
        if ftype == UI_SCROLL
          draw_border = 1.0
        end
        if ftype == UI_TABLE
          draw_border = 1.0
        end
        if ftype == UI_TREEVIEW
          draw_border = 1.0
        end
        if ftype == UI_TEXTAREA
          draw_border = 1.0
        end
        if draw_border == 1.0
          if _ui_enabled[fi] == 0.0
            draw_border = 0.0
          end
        end
        if draw_border == 1.0
          let bpad = 2.0
          _ui_pc_rect[0] = _ui_x[fi] - bpad
          _ui_pc_rect[1] = _ui_y[fi] - bpad
          _ui_pc_rect[2] = _ui_w[fi] + bpad * 2.0
          _ui_pc_rect[3] = _ui_h[fi] + bpad * 2.0
          _ui_pc_rect[4] = ui_theme_r(UI_COLOR_PRIMARY)
          _ui_pc_rect[5] = ui_theme_g(UI_COLOR_PRIMARY)
          _ui_pc_rect[6] = ui_theme_b(UI_COLOR_PRIMARY)
          _ui_pc_rect[7] = w
          _ui_pc_rect[8] = total
          let bpixels = ((_ui_w[fi] + bpad * 2.0) * (_ui_h[fi] + bpad * 2.0))
          let bwg = floor((bpixels + 255.0) / 256.0)
          let _db = vm_dispatch(vm, _ui_spv_rect, _ui_pc_rect, bwg)
        end
      end
    end
  end

  // ── 2. Draw widget rectangles ──
  let mut ri = 0.0
  while ri < n
    if _ui_visible[ri] == 1.0
      let wtype = _ui_types[ri]
      if wtype == UI_BOX
        let _dr = ui_pipeline_dispatch_rect(vm, ri, w, total)
      end
      if wtype == UI_BUTTON
        let _dr = ui_pipeline_dispatch_rect(vm, ri, w, total)
      end
      if wtype == UI_CHECKBOX
        let _dr = ui_pipeline_dispatch_rect(vm, ri, w, total)
      end
      if wtype == UI_TEXTINPUT
        let _dr = ui_pipeline_dispatch_rect(vm, ri, w, total)
      end
      if wtype == UI_SLIDER
        let _dr = ui_pipeline_dispatch_rect(vm, ri, w, total)
      end
      if wtype == UI_RADIO
        let _dr = ui_pipeline_dispatch_rect(vm, ri, w, total)
      end
      if wtype == UI_TOGGLE
        let _dr = ui_pipeline_dispatch_rect(vm, ri, w, total)
      end
      if wtype == UI_LISTBOX
        let _dr = ui_pipeline_dispatch_rect(vm, ri, w, total)
      end
      if wtype == UI_SPINBOX
        let _dr = ui_pipeline_dispatch_rect(vm, ri, w, total)
      end
      if wtype == UI_SCROLL
        let _dr = ui_pipeline_dispatch_rect(vm, ri, w, total)
      end
      if wtype == UI_TABLE
        let _dr = ui_pipeline_dispatch_rect(vm, ri, w, total)
      end
      if wtype == UI_TREEVIEW
        let _dr = ui_pipeline_dispatch_rect(vm, ri, w, total)
      end
      if wtype == UI_TEXTAREA
        let _dr = ui_pipeline_dispatch_rect(vm, ri, w, total)
      end
    end
    ri = ri + 1.0
  end

  // ── 3. Draw text blits (from text queue) ──
  let tq_len = len(_ui_tq)
  let mut ti = 0.0
  while ti < tq_len
    let bidx = _ui_tq[ti]
    let tx = _ui_tq[ti + 1.0]
    let ty = _ui_tq[ti + 2.0]
    let cr = _ui_tq[ti + 3.0]
    let cg = _ui_tq[ti + 4.0]
    let cb = _ui_tq[ti + 5.0]
    let _d = ui_pipeline_dispatch_text_blit(vm, bidx, tx, ty, cr, cg, cb, w, total)
    ti = ti + 6.0
  end

  // ── 3a. TEXTINPUT cursor ──
  if _ui_focus_id >= 0.0
    let fi = _ui_focus_id
    if fi < len(_ui_types)
      if _ui_types[fi] == UI_TEXTINPUT
        if _ui_enabled[fi] == 1.0
          let mut draw_cursor = 1.0
          if fi < len(_ui_ti_readonly)
            if _ui_ti_readonly[fi] == 1.0
              draw_cursor = 0.0
            end
          end
          if draw_cursor == 1.0
            let font_size = 16.0
            let text_pad = 6.0
            // Determine display text (same logic as collection)
            let text = _ui_texts[fi]
            let mut display_text = text
            let mut is_empty = 0.0
            if text == " "
              is_empty = 1.0
            end
            if is_empty == 1.0
              if fi < len(_ui_ti_placeholder)
                let ph = _ui_ti_placeholder[fi]
                if ph != " "
                  display_text = ph
                end
              end
            end
            let mut is_password = 0.0
            if fi < len(_ui_ti_password)
              if _ui_ti_password[fi] == 1.0
                is_password = 1.0
              end
            end
            if is_password == 1.0
              if is_empty == 0.0
                let tlen = len(display_text)
                let mut masked = chr(42.0)
                let mut mi = 1.0
                while mi < tlen
                  masked = masked + chr(42.0)
                  mi = mi + 1.0
                end
                display_text = masked
              end
            end

            let mut cpos = len(display_text)
            if fi < len(_ui_ti_cursor)
              cpos = _ui_ti_cursor[fi]
            end
            let cursor_x = _ui_x[fi] + text_pad + gdi_text_width(substr(display_text, 0.0, cpos), font_size)
            let cursor_y = _ui_y[fi] + 3.0
            let cursor_h = _ui_h[fi] - 6.0
            let c_cr = ui_theme_r(UI_COLOR_TEXT)
            let c_cg = ui_theme_g(UI_COLOR_TEXT)
            let c_cb = ui_theme_b(UI_COLOR_TEXT)
            _ui_pc_rect[0] = cursor_x
            _ui_pc_rect[1] = cursor_y
            _ui_pc_rect[2] = 2.0
            _ui_pc_rect[3] = cursor_h
            _ui_pc_rect[4] = c_cr
            _ui_pc_rect[5] = c_cg
            _ui_pc_rect[6] = c_cb
            _ui_pc_rect[7] = w
            _ui_pc_rect[8] = total
            let cpx = 2.0 * cursor_h
            let cwg = floor((cpx + 255.0) / 256.0)
            let _dcur = vm_dispatch(vm, _ui_spv_rect, _ui_pc_rect, cwg)
          end
        end
      end
    end
  end

  // ── 3b. TEXTAREA cursor ──
  if _ui_focus_id >= 0.0
    let fi = _ui_focus_id
    if fi < len(_ui_types)
      if _ui_types[fi] == UI_TEXTAREA
        let mut ta_idx = -1.0
        let mut tai = 0.0
        while tai < len(_ui_ta_widgets)
          if _ui_ta_widgets[tai] == fi
            ta_idx = tai
          end
          tai = tai + 1.0
        end
        if ta_idx >= 0.0
          let is_ro = _ui_ta_readonly[ta_idx]
          if is_ro == 0.0
            let font_size = 16.0
            let line_h = 16.0
            let text_pad = 4.0
            let cur_line = _ui_ta_cursor_line[ta_idx]
            let cur_col = _ui_ta_cursor_col[ta_idx]
            let scroll = _ui_ta_scroll[ta_idx]
            let bh = _ui_h[fi]
            let vis_lines = floor(bh / line_h)

            if cur_line >= scroll
              let vis_end = scroll + vis_lines
              if cur_line < vis_end
                let rel_line = cur_line - scroll
                let start = _ui_ta_line_start[ta_idx]
                let flat_cur = start + cur_line
                let cur_text = _ui_ta_lines[flat_cur]
                let cursor_x = _ui_x[fi] + text_pad + gdi_text_width(substr(cur_text, 0.0, cur_col), font_size)
                let cursor_y = _ui_y[fi] + rel_line * line_h + 1.0
                let cursor_h = line_h - 2.0
                let cr = ui_theme_r(UI_COLOR_TEXT)
                let cg = ui_theme_g(UI_COLOR_TEXT)
                let cb = ui_theme_b(UI_COLOR_TEXT)
                _ui_pc_rect[0] = cursor_x
                _ui_pc_rect[1] = cursor_y
                _ui_pc_rect[2] = 2.0
                _ui_pc_rect[3] = cursor_h
                _ui_pc_rect[4] = cr
                _ui_pc_rect[5] = cg
                _ui_pc_rect[6] = cb
                _ui_pc_rect[7] = w
                _ui_pc_rect[8] = total
                let cpx = 2.0 * cursor_h
                let cwg = floor((cpx + 255.0) / 256.0)
                let _dcur = vm_dispatch(vm, _ui_spv_rect, _ui_pc_rect, cwg)
              end
            end
          end
        end
      end
    end
  end

  // ── 4. Tooltip overlay ──
  if tt_visible == 1.0
    let tt_x = ui_tooltip_x()
    let tt_y = ui_tooltip_y()
    let tt_text = ui_tooltip_text()
    let tt_font = 14.0
    let tt_pad = 4.0
    let tt_w = ui_text_width(tt_text, tt_font) + tt_pad * 2.0
    let tt_h = gdi_text_height(tt_font) + tt_pad * 2.0

    // Border rect
    _ui_pc_rect[0] = tt_x - 1.0
    _ui_pc_rect[1] = tt_y - 1.0
    _ui_pc_rect[2] = tt_w + 2.0
    _ui_pc_rect[3] = tt_h + 2.0
    _ui_pc_rect[4] = ui_theme_r(UI_COLOR_BORDER)
    _ui_pc_rect[5] = ui_theme_g(UI_COLOR_BORDER)
    _ui_pc_rect[6] = ui_theme_b(UI_COLOR_BORDER)
    _ui_pc_rect[7] = w
    _ui_pc_rect[8] = total
    let tt_bp = (tt_w + 2.0) * (tt_h + 2.0)
    let tt_bwg = floor((tt_bp + 255.0) / 256.0)
    let _dttb = vm_dispatch(vm, _ui_spv_rect, _ui_pc_rect, tt_bwg)

    // Background rect
    _ui_pc_rect[0] = tt_x
    _ui_pc_rect[1] = tt_y
    _ui_pc_rect[2] = tt_w
    _ui_pc_rect[3] = tt_h
    _ui_pc_rect[4] = ui_theme_r(UI_COLOR_SURFACE)
    _ui_pc_rect[5] = ui_theme_g(UI_COLOR_SURFACE)
    _ui_pc_rect[6] = ui_theme_b(UI_COLOR_SURFACE)
    let tt_pixels = tt_w * tt_h
    let tt_wg = floor((tt_pixels + 255.0) / 256.0)
    let _dttf = vm_dispatch(vm, _ui_spv_rect, _ui_pc_rect, tt_wg)

    // Tooltip text blit
    let _dtt = ui_pipeline_dispatch_text_blit(vm, tt_bidx, tt_bx, tt_by, tt_cr, tt_cg, tt_cb, w, total)
  end

  // ── 5. Notification overlay ──
  if nt_visible == 1.0
    let nt_x = ui_notify_x()
    let nt_y = ui_notify_y()
    let nt_text = ui_notify_text()
    let nt_font = 16.0
    let nt_pad = 8.0
    let nt_w = ui_text_width(nt_text, nt_font) + nt_pad * 2.0
    let nt_h = nt_font + nt_pad * 2.0
    let nt_cidx = ui_notify_color()

    // Background rect
    _ui_pc_rect[0] = nt_x
    _ui_pc_rect[1] = nt_y
    _ui_pc_rect[2] = nt_w
    _ui_pc_rect[3] = nt_h
    _ui_pc_rect[4] = ui_theme_r(nt_cidx)
    _ui_pc_rect[5] = ui_theme_g(nt_cidx)
    _ui_pc_rect[6] = ui_theme_b(nt_cidx)
    _ui_pc_rect[7] = w
    _ui_pc_rect[8] = total
    let nt_pixels = nt_w * nt_h
    let nt_wg = floor((nt_pixels + 255.0) / 256.0)
    let _dnt = vm_dispatch(vm, _ui_spv_rect, _ui_pc_rect, nt_wg)

    // Notification text blit
    let _dntb = ui_pipeline_dispatch_text_blit(vm, nt_bidx, nt_bx, nt_by, nt_cr, nt_cg, nt_cb, w, total)
  end

  // ── 6. Modal overlay ──
  if modal_cid >= 0.0
    // Dim overlay
    _ui_pc_rect[0] = 0.0
    _ui_pc_rect[1] = 0.0
    _ui_pc_rect[2] = w
    _ui_pc_rect[3] = h
    let dim_r = floor(ui_theme_r(UI_COLOR_BG) / 2.0)
    let dim_g = floor(ui_theme_g(UI_COLOR_BG) / 2.0)
    let dim_b = floor(ui_theme_b(UI_COLOR_BG) / 2.0)
    _ui_pc_rect[4] = dim_r
    _ui_pc_rect[5] = dim_g
    _ui_pc_rect[6] = dim_b
    _ui_pc_rect[7] = w
    _ui_pc_rect[8] = total
    let dim_wg = floor((total + 255.0) / 256.0)
    let _ddim = vm_dispatch(vm, _ui_spv_rect, _ui_pc_rect, dim_wg)

    // Re-render modal widget rects
    let mut mi = 0.0
    while mi < n
      if _ui_visible[mi] == 1.0
        if ui_tree_is_descendant(mi, modal_cid) == 1.0
          let mwtype = _ui_types[mi]
          let mut mdraw = 0.0
          if mwtype == UI_BOX
            mdraw = 1.0
          end
          if mwtype == UI_BUTTON
            mdraw = 1.0
          end
          if mwtype == UI_CHECKBOX
            mdraw = 1.0
          end
          if mwtype == UI_TEXTINPUT
            mdraw = 1.0
          end
          if mwtype == UI_SLIDER
            mdraw = 1.0
          end
          if mwtype == UI_RADIO
            mdraw = 1.0
          end
          if mwtype == UI_TOGGLE
            mdraw = 1.0
          end
          if mwtype == UI_COLUMN
            if _ui_color_idx[mi] >= 0.0
              mdraw = 1.0
            end
          end
          if mwtype == UI_ROW
            if _ui_color_idx[mi] >= 0.0
              mdraw = 1.0
            end
          end
          if mwtype == UI_TABLE
            mdraw = 1.0
          end
          if mwtype == UI_TREEVIEW
            mdraw = 1.0
          end
          if mwtype == UI_TEXTAREA
            mdraw = 1.0
          end
          if mdraw == 1.0
            let _mdr = ui_pipeline_dispatch_rect(vm, mi, w, total)
          end
        end
      end
      mi = mi + 1.0
    end

    // Re-render modal text blits
    let mq_len = len(_ui_tq_modal)
    let mut mti = 0.0
    while mti < mq_len
      let mbidx = _ui_tq_modal[mti]
      let mtx = _ui_tq_modal[mti + 1.0]
      let mty = _ui_tq_modal[mti + 2.0]
      let mcr = _ui_tq_modal[mti + 3.0]
      let mcg = _ui_tq_modal[mti + 4.0]
      let mcb = _ui_tq_modal[mti + 5.0]
      let _md = ui_pipeline_dispatch_text_blit(vm, mbidx, mtx, mty, mcr, mcg, mcb, w, total)
      mti = mti + 6.0
    end
  end

  // ── 7. Build single command buffer ──
  let prog = vm_build(vm)

  // ── 8. Async submit — GPU renders while CPU handles next frame ──
  let _ea = vm_execute_async(prog)
  _ui_vm[5] = prog

  return 0.0
end

// Present the rendered frame to the window
fn ui_pipeline_present()
  // Inline present_pending (avoid fn call — snapshot clones ~250K floats)
  let prev = _ui_vm[5]
  if prev >= 0.0
    let _w = vm_wait(prev)
    let vm = _ui_vm[0]
    let total = _ui_vm[4]
    let _p = vm_present(vm, total)
    let _f = vm_free_prog(prev)
    _ui_vm[5] = -1.0
  end
  return 0.0
end

// Shut down the render pipeline
fn ui_pipeline_shutdown()
  let prev = _ui_vm[5]
  if prev >= 0.0
    let _w = vm_wait(prev)
    let svm = _ui_vm[0]
    let stotal = _ui_vm[4]
    let _p = vm_present(svm, stotal)
    let _f = vm_free_prog(prev)
    _ui_vm[5] = -1.0
  end
  let vm = _ui_vm[0]
  let _s = vm_shutdown(vm)
  _ui_vm[3] = 0.0
  return 0.0
end

// ── Internal helpers ──

// Dispatch a rect for widget at index i
fn ui_pipeline_dispatch_rect(vm, idx, screen_w, total)
  let x0 = _ui_x[idx]
  let y0 = _ui_y[idx]
  let rw = _ui_w[idx]
  let rh = _ui_h[idx]
  let mut cr = _ui_colors_r[idx]
  let mut cg = _ui_colors_g[idx]
  let mut cb = _ui_colors_b[idx]

  // Dim disabled widgets
  if _ui_enabled[idx] == 0.0
    let dbg_r = ui_theme_r(UI_COLOR_BG)
    let dbg_g = ui_theme_g(UI_COLOR_BG)
    let dbg_b = ui_theme_b(UI_COLOR_BG)
    cr = floor(cr * 0.4 + dbg_r * 0.6)
    cg = floor(cg * 0.4 + dbg_g * 0.6)
    cb = floor(cb * 0.4 + dbg_b * 0.6)
  end

  _ui_pc_rect[0] = x0
  _ui_pc_rect[1] = y0
  _ui_pc_rect[2] = rw
  _ui_pc_rect[3] = rh
  _ui_pc_rect[4] = cr
  _ui_pc_rect[5] = cg
  _ui_pc_rect[6] = cb
  _ui_pc_rect[7] = screen_w
  _ui_pc_rect[8] = total

  let pixels = rw * rh
  let wg = floor((pixels + 255.0) / 256.0)
  let _d = vm_dispatch(vm, _ui_spv_rect, _ui_pc_rect, wg)
  return 0.0
end

// Dispatch text blit for a batch entry
fn ui_pipeline_dispatch_text_blit(vm, bidx, dest_x, dest_y, cr, cg, cb, screen_w, total)
  let tw = gdi_text_w(bidx)
  let th = gdi_text_h(bidx)
  let toff = gdi_text_off(bidx)
  let threads = tw * th
  if threads < 1.0
    return 0.0
  end
  let wg = floor((threads + 255.0) / 256.0)
  _ui_pc_blit[0] = dest_x
  _ui_pc_blit[1] = dest_y
  _ui_pc_blit[2] = tw
  _ui_pc_blit[3] = th
  _ui_pc_blit[4] = cr
  _ui_pc_blit[5] = cg
  _ui_pc_blit[6] = cb
  _ui_pc_blit[7] = screen_w
  _ui_pc_blit[8] = total
  _ui_pc_blit[9] = toff
  let _d = vm_dispatch(vm, _ui_blit_spv, _ui_pc_blit, wg)
  return 0.0
end
